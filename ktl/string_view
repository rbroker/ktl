#pragma once

#include <ktl_core.h>
#include <ntstrsafe.h>

#include <algorithm>
#include <type_traits>
#include <hash_impl.h>

namespace ktl
{
	struct unicode_string_view
	{
		static const size_t npos = MAXSIZE_T;

		constexpr unicode_string_view():
			str_ {}
		{
		}

		constexpr unicode_string_view(PUNICODE_STRING str)
		{
			if (str == nullptr)
				str_ = {};
			else
				str_ = *str;
		}

		constexpr unicode_string_view(const wchar_t* str, size_t length = npos)
		{
			str_.Buffer = const_cast<PWCH>(str);
			str_.MaximumLength = 0;
			str_.Length = 0;

			for (size_t i = 0; str[i] != UNICODE_NULL; ++i)
			{
				++(str_.MaximumLength);

				if (i <= length)
					++(str_.Length);
			}

			str_.Length *= sizeof(wchar_t);
			str_.MaximumLength *= sizeof(wchar_t);
		}

		unicode_string_view(const unicode_string_view& other) :
			str_(other.str_)
		{
		}

		/// <summary>
		/// Size of view, in characters
		/// </summary>
		inline constexpr size_t size() const
		{
			return str_.Length / sizeof(wchar_t);
		}

		/// <summary>
		/// Size of view in bytes, excluding null terminator
		/// </summary>
		inline constexpr size_t byte_size() const
		{
			return str_.Length;
		}

		inline constexpr size_t max_size() const
		{
			return NTSTRSAFE_UNICODE_STRING_MAX_CCH - 1;
		}

		inline constexpr PCUNICODE_STRING data() const
		{
			return &str_;
		}

		inline PUNICODE_STRING data()
		{
			return &str_;
		}

		inline constexpr PCUNICODE_STRING operator&() const
		{
			return data();
		}

		inline PUNICODE_STRING operator&()
		{
			return data();
		}

		constexpr unicode_string_view substr(size_t pos = 0, size_t count = npos)
		{
			if (pos > size())
				return {};

			if (count == npos || ((pos + count) > size()))
				count = size() - pos;

			unicode_string_view sub{ str_.Buffer + pos, count };
			return sub;
		}

		template<typename string_type>
		constexpr bool starts_with(const string_type& prefix)
		{
			if (size() < prefix.size())
				return false;

			auto sub = substr(0, prefix.size());
			return sub == prefix;
		}

		template<typename string_type>
		constexpr bool ends_with(const string_type& suffix)
		{
			if (size() < suffix.size())
				return false;

			auto sub = substr(size() - suffix.size());
			return sub == suffix;
		}

		template<typename string_type>
		constexpr bool operator==(const string_type& other) const
		{
			return compare(other) == 0;
		}

		constexpr bool operator!=(const unicode_string_view& other) const
		{
			return compare(other) != 0;
		}

		template<class T>
		constexpr int compare(const T& other, bool caseInsensitive = false) const
		{
			return RtlCompareUnicodeString(data(), other.data(), caseInsensitive ? TRUE : FALSE);
		}

		wchar_t operator[](size_t index)
		{
			return str_.Buffer[index];
		}

	private:
		UNICODE_STRING str_ = {};
	};

	template<>
	struct hash<unicode_string_view>
	{
		[[nodiscard]] hash_t operator()(const unicode_string_view& value) const
		{
			return wyhash(value.data()->Buffer, value.byte_size(), 0, _wyp);
		}
	};
}